'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// Production steps of ECMA-262, Edition 6, 22.1.2.1
if (!Array.from) {
  Array.from = function () {
    var toStr = Object.prototype.toString;
    var isCallable = function isCallable(fn) {
      return typeof fn === 'function' || toStr.call(fn) === '[object Function]';
    };
    var toInteger = function toInteger(value) {
      var number = Number(value);
      if (isNaN(number)) {
        return 0;
      }
      if (number === 0 || !isFinite(number)) {
        return number;
      }
      return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
    };
    var maxSafeInteger = Math.pow(2, 53) - 1;
    var toLength = function toLength(value) {
      var len = toInteger(value);
      return Math.min(Math.max(len, 0), maxSafeInteger);
    };

    // The length property of the from method is 1.
    return function from(arrayLike /*, mapFn, thisArg */) {
      // 1. Let C be the this value.
      var C = this;

      // 2. Let items be ToObject(arrayLike).
      var items = Object(arrayLike);

      // 3. ReturnIfAbrupt(items).
      if (arrayLike == null) {
        throw new TypeError('Array.from requires an array-like object - not null or undefined');
      }

      // 4. If mapfn is undefined, then let mapping be false.
      var mapFn = arguments.length > 1 ? arguments[1] : void undefined;
      var T;
      if (typeof mapFn !== 'undefined') {
        // 5. else
        // 5. a If IsCallable(mapfn) is false, throw a TypeError exception.
        if (!isCallable(mapFn)) {
          throw new TypeError('Array.from: when provided, the second argument must be a function');
        }

        // 5. b. If thisArg was supplied, let T be thisArg; else let T be undefined.
        if (arguments.length > 2) {
          T = arguments[2];
        }
      }

      // 10. Let lenValue be Get(items, "length").
      // 11. Let len be ToLength(lenValue).
      var len = toLength(items.length);

      // 13. If IsConstructor(C) is true, then
      // 13. a. Let A be the result of calling the [[Construct]] internal method 
      // of C with an argument list containing the single item len.
      // 14. a. Else, Let A be ArrayCreate(len).
      var A = isCallable(C) ? Object(new C(len)) : new Array(len);

      // 16. Let k be 0.
      var k = 0;
      // 17. Repeat, while k < lenâ€¦ (also steps a - h)
      var kValue;
      while (k < len) {
        kValue = items[k];
        if (mapFn) {
          A[k] = typeof T === 'undefined' ? mapFn(kValue, k) : mapFn.call(T, kValue, k);
        } else {
          A[k] = kValue;
        }
        k += 1;
      }
      // 18. Let putStatus be Put(A, "length", len, true).
      A.length = len;
      // 20. Return A.
      return A;
    };
  }();
}
// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
function debounce(func, wait, immediate) {
  var timeout;
  return function () {
    var context = this,
        args = arguments;
    var later = function later() {
      timeout = null;
      if (!immediate) func.apply(context, args);
    };
    var callNow = immediate && !timeout;
    clearTimeout(timeout);
    timeout = setTimeout(later, wait);
    if (callNow) func.apply(context, args);
  };
};
if (window.NodeList && !NodeList.prototype.forEach) {
  NodeList.prototype.forEach = function (callback, thisArg) {
    thisArg = thisArg || window;
    for (var i = 0; i < this.length; i++) {
      callback.call(thisArg, this[i], i, this);
    }
  };
}
if (typeof Object.assign !== 'function') {
  // Must be writable: true, enumerable: false, configurable: true
  Object.defineProperty(Object, "assign", {
    value: function assign(target, varArgs) {
      // .length of function is 2
      'use strict';

      if (target === null || target === undefined) {
        throw new TypeError('Cannot convert undefined or null to object');
      }

      var to = Object(target);

      for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource !== null && nextSource !== undefined) {
          for (var nextKey in nextSource) {
            // Avoid bugs when hasOwnProperty is shadowed
            if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    writable: true,
    configurable: true
  });
}
/**
 * TinyGesture.js
 *
 * This service uses passive listeners, so you can't call event.preventDefault()
 * on any of the events.
 *
 * Adapted from https://gist.github.com/SleepWalker/da5636b1abcbaff48c4d
 * and https://github.com/uxitten/xwiper
 */

var TinyGesture = function () {
  function TinyGesture(element, options) {
    _classCallCheck(this, TinyGesture);

    options = Object.assign({}, TinyGesture.defaults, options);
    this.element = element;
    this.opts = options;
    this.touchStartX = null;
    this.touchStartY = null;
    this.touchEndX = null;
    this.touchEndY = null;
    this.velocityX = null;
    this.velocityY = null;
    this.longPressTimer = null;
    this.doubleTapWaiting = false;
    this.handlers = {
      'panstart': [],
      'panmove': [],
      'panend': [],
      'swipeleft': [],
      'swiperight': [],
      'swipeup': [],
      'swipedown': [],
      'tap': [],
      'doubletap': [],
      'longpress': []
    };

    this._onTouchStart = this.onTouchStart.bind(this);
    this._onTouchMove = this.onTouchMove.bind(this);
    this._onTouchEnd = this.onTouchEnd.bind(this);

    this.element.addEventListener('touchstart', this._onTouchStart, passiveIfSupported);
    this.element.addEventListener('touchmove', this._onTouchMove, passiveIfSupported);
    this.element.addEventListener('touchend', this._onTouchEnd, passiveIfSupported);

    if (this.opts.mouseSupport && !('ontouchstart' in window)) {
      this.element.addEventListener('mousedown', this._onTouchStart, passiveIfSupported);
      document.addEventListener('mousemove', this._onTouchMove, passiveIfSupported);
      document.addEventListener('mouseup', this._onTouchEnd, passiveIfSupported);
    }
  }

  _createClass(TinyGesture, [{
    key: 'destroy',
    value: function destroy() {
      this.element.removeEventListener('touchstart', this._onTouchStart);
      this.element.removeEventListener('touchmove', this._onTouchMove);
      this.element.removeEventListener('touchend', this._onTouchEnd);
      this.element.removeEventListener('mousedown', this._onTouchStart);
      document.removeEventListener('mousemove', this._onTouchMove);
      document.removeEventListener('mouseup', this._onTouchEnd);
      clearTimeout(this.longPressTimer);
      clearTimeout(this.doubleTapTimer);
    }
  }, {
    key: 'on',
    value: function on(type, fn) {
      var _this = this;

      if (this.handlers[type]) {
        this.handlers[type].push(fn);
        return {
          type: type,
          fn: fn,
          cancel: function cancel() {
            return _this.off(type, fn);
          }
        };
      }
    }
  }, {
    key: 'off',
    value: function off(type, fn) {
      if (this.handlers[type]) {
        var idx = this.handlers[type].indexOf(fn);
        if (idx !== -1) {
          this.handlers[type].splice(idx, 1);
        }
      }
    }
  }, {
    key: 'fire',
    value: function fire(type, event) {
      for (var i = 0; i < this.handlers[type].length; i++) {
        this.handlers[type][i](event);
      }
    }
  }, {
    key: 'onTouchStart',
    value: function onTouchStart(event) {
      var _this2 = this;

      this.thresholdX = this.opts.threshold('x', this);
      this.thresholdY = this.opts.threshold('y', this);
      this.disregardVelocityThresholdX = this.opts.disregardVelocityThreshold('x', this);
      this.disregardVelocityThresholdY = this.opts.disregardVelocityThreshold('y', this);
      this.touchStartX = event.type === 'mousedown' ? event.screenX : event.changedTouches[0].screenX;
      this.touchStartY = event.type === 'mousedown' ? event.screenY : event.changedTouches[0].screenY;
      this.touchMoveX = null;
      this.touchMoveY = null;
      this.touchEndX = null;
      this.touchEndY = null;
      // Long press.
      this.longPressTimer = setTimeout(function () {
        return _this2.fire('longpress', event);
      }, this.opts.longPressTime);
      this.fire('panstart', event);
    }
  }, {
    key: 'onTouchMove',
    value: function onTouchMove(event) {
      if (event.type === 'mousemove' && (!this.touchStartX || this.touchEndX !== null)) {
        return;
      }
      var touchMoveX = (event.type === 'mousemove' ? event.screenX : event.changedTouches[0].screenX) - this.touchStartX;
      this.velocityX = touchMoveX - this.touchMoveX;
      this.touchMoveX = touchMoveX;
      var touchMoveY = (event.type === 'mousemove' ? event.screenY : event.changedTouches[0].screenY) - this.touchStartY;
      this.velocityY = touchMoveY - this.touchMoveY;
      this.touchMoveY = touchMoveY;
      var absTouchMoveX = Math.abs(this.touchMoveX);
      var absTouchMoveY = Math.abs(this.touchMoveY);
      this.swipingHorizontal = absTouchMoveX > this.thresholdX;
      this.swipingVertical = absTouchMoveY > this.thresholdY;
      this.swipingDirection = absTouchMoveX > absTouchMoveY ? this.swipingHorizontal ? 'horizontal' : 'pre-horizontal' : this.swipingVertical ? 'vertical' : 'pre-vertical';
      if (Math.max(absTouchMoveX, absTouchMoveY) > this.opts.pressThreshold) {
        clearTimeout(this.longPressTimer);
      }
      this.fire('panmove', event);
    }
  }, {
    key: 'onTouchEnd',
    value: function onTouchEnd(event) {
      var _this3 = this;

      if (event.type === 'mouseup' && (!this.touchStartX || this.touchEndX !== null)) {
        return;
      }
      this.touchEndX = event.type === 'mouseup' ? event.screenX : event.changedTouches[0].screenX;
      this.touchEndY = event.type === 'mouseup' ? event.screenY : event.changedTouches[0].screenY;
      this.fire('panend', event);
      clearTimeout(this.longPressTimer);

      var x = this.touchEndX - this.touchStartX;
      var absX = Math.abs(x);
      var y = this.touchEndY - this.touchStartY;
      var absY = Math.abs(y);

      if (absX > this.thresholdX || absY > this.thresholdY) {
        this.swipedHorizontal = this.opts.diagonalSwipes ? Math.abs(x / y) <= this.opts.diagonalLimit : absX >= absY && absX > this.thresholdX;
        this.swipedVertical = this.opts.diagonalSwipes ? Math.abs(y / x) <= this.opts.diagonalLimit : absY > absX && absY > this.thresholdY;
        if (this.swipedHorizontal) {
          if (x < 0) {
            // Left swipe.
            if (this.velocityX < -this.opts.velocityThreshold || x < -this.disregardVelocityThresholdX) {
              this.fire('swipeleft', event);
            }
          } else {
            // Right swipe.
            if (this.velocityX > this.opts.velocityThreshold || x > this.disregardVelocityThresholdX) {
              this.fire('swiperight', event);
            }
          }
        }
        if (this.swipedVertical) {
          if (y < 0) {
            // Upward swipe.
            if (this.velocityY < -this.opts.velocityThreshold || y < -this.disregardVelocityThresholdY) {
              this.fire('swipeup', event);
            }
          } else {
            // Downward swipe.
            if (this.velocityY > this.opts.velocityThreshold || y > this.disregardVelocityThresholdY) {
              this.fire('swipedown', event);
            }
          }
        }
      } else if (absX < this.opts.pressThreshold && absY < this.opts.pressThreshold) {
        // Tap.
        if (this.doubleTapWaiting) {
          this.doubleTapWaiting = false;
          clearTimeout(this.doubleTapTimer);
          this.fire('doubletap', event);
        } else {
          this.doubleTapWaiting = true;
          this.doubleTapTimer = setTimeout(function () {
            return _this3.doubleTapWaiting = false;
          }, this.opts.doubleTapTime);
          this.fire('tap', event);
        }
      }
    }
  }]);

  return TinyGesture;
}();

TinyGesture.defaults = {
  threshold: function threshold(type, self) {
    return Math.max(25, Math.floor(0.15 * (type === 'x' ? window.innerWidth || document.body.clientWidth : window.innerHeight || document.body.clientHeight)));
  },
  velocityThreshold: 10,
  disregardVelocityThreshold: function disregardVelocityThreshold(type, self) {
    return Math.floor(0.5 * (type === 'x' ? self.element.clientWidth : self.element.clientHeight));
  },
  pressThreshold: 8,
  diagonalSwipes: false,
  diagonalLimit: Math.tan(45 * 1.5 / 180 * Math.PI),
  longPressTime: 500,
  doubleTapTime: 300,
  mouseSupport: true
};

// Passive feature detection.
var passiveIfSupported = false;

try {
  window.addEventListener('test', null, Object.defineProperty({}, 'passive', { get: function get() {
      passiveIfSupported = { passive: true };
    } }));
} catch (err) {}
//@prepros-prepend lib/Array.from.js
//@prepros-prepend lib/Debounce.js
//@prepros-prepend lib/NodeList.forEach.js
//@prepros-prepend lib/Object.assign.js
//@prepros-prepend lib/TinyGesture.js

var A11yCarousel = function A11yCarousel(selector, userSettings) {
  var _this4 = this;

  _classCallCheck(this, A11yCarousel);

  this.setSlider = debounce(function () {
    var sliderIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;

    // If last slider, got to the first one
    if (sliderIndex >= _this4._slides.length) {
      sliderIndex = 0;
    }

    // If first slider, got to the last one
    if (sliderIndex < 0) {
      sliderIndex = _this4._slides.length - 1;
    }

    // If current slider do nothing
    if (_this4._sliderIndex == sliderIndex) {
      return null;
    }

    // Annimation
    var oldIndex = _this4._sliderIndex;
    var newIndex = sliderIndex;
    _this4._sliderIndex = sliderIndex;

    _this4._slides[oldIndex].style.opacity = 0;
    _this4._slides[oldIndex].style.zIndex = 2;
    _this4._slides[newIndex].style.zIndex = 1;
    _this4._slides[newIndex].style.display = 'block';

    // Active class for Dot
    if (_this4.getSettings().dots) {
      var dots = Array.from(_this4.dotsWrapper.children);
      dots.forEach(function (item) {
        if (item.getAttribute('slider-id') == newIndex) {
          item.classList.add('active');
          item.setAttribute('tabindex', 0);
        } else {
          item.classList.remove('active');
          item.setAttribute('tabindex', -1);
        }
      });
    }

    // When the Annimation is over
    setTimeout(function () {
      _this4._slides[oldIndex].style.zIndex = 1;
      _this4._slides[newIndex].style.zIndex = 2;
      _this4._slides[oldIndex].style.opacity = null;
      _this4._slides[oldIndex].style.display = 'none';
    }, parseInt(_this4.getSettings().transitionSpeed) + 100); // Need more time than transitionSpeed to avoid annimation glitches
  }, 200);

  this.initSlidesSize = function () {
    var imgs = Array.from(_this4._element.querySelectorAll('img'));
    // If there's no imgs or the imgs are cached
    if (imgs.length == 0) {
      _this4.setSize();
    } else {
      _this4.setSize();
      // If there's imgs and when need to wait them
      imgs[imgs.length - 1].addEventListener('load', function () {
        _this4.setSize();
      });
    }
  };

  this.setSize = debounce(function () {
    if (_this4.getSettings().width !== 'auto') {
      _this4._element.style.width = _this4.getSettings().width;
      _this4._element.style.maxWidth = _this4.getSettings().width;
      _this4._element.style.overflowX = 'hidden';
    }

    if (_this4.getSettings().height !== 'auto') {
      _this4._element.style.height = _this4.getSettings().height;
      _this4._element.style.maxHeight = _this4.getSettings().height;
      _this4._element.style.overflowY = 'hidden';
    } else {
      _this4._element.style.height = _this4._slides[_this4._sliderIndex].offsetHeight + 'px';
    }
  }, 100);

  this.autoPlay = function () {
    if (_this4._canAutoSlide) {
      _this4.setSlider(parseInt(_this4._sliderIndex) + 1);
    }
  };

  this.getSettings = function () {
    return _this4.settings;
  };

  // Default Settings of the Slide show
  var defaultSettings = {
    autoplay: true,
    autoplaySpeed: 7000,
    transitionSpeed: 300,
    arrows: true,
    dots: false,
    sliderIndex: 0,
    width: 'auto',
    height: 'auto',
    gesture: true,
    pauseOnHover: true,
    className: 'a11y-carousel',
    ariaRoledescription: 'carousel',
    ariaLabel: 'Slideshow description',
    playText: 'Start slide show',
    pauseText: 'Stop slide show',
    previousText: 'Previous',
    nextText: 'Next',
    ofText: 'of',
    slideText: 'Slide',
    tablistText: 'Choose slide to display'
  };

  // Merge the default settings with the user settings
  this.settings = _extends({}, defaultSettings, userSettings);

  // Default global variables
  this._selector = selector;
  this._element = document.querySelector(selector);
  this._playId = this._selector.slice(1) + '-play';
  this._prevId = this._selector.slice(1) + '-prev';
  this._nextId = this._selector.slice(1) + '-next';
  this._sliderIndex = this.getSettings().sliderIndex;
  this._wasPlaying = this.getSettings().autoplay;
  this._canAutoSlide = true;
  this._autoPlayInterval = null;

  if (this.getSettings().transitionSpeed > this.getSettings().autoplaySpeed) {
    throw 'a11y Carousel: \uD83E\uDD1A transitionSpeed can be greater than autoplaySpeed';
  }

  // Create a wrapper for the whole slide show
  var sliderWrapper = document.createElement('div');
  sliderWrapper.setAttribute('aria-roledescription', this.getSettings().ariaRoledescription);
  sliderWrapper.setAttribute('aria-label', this.getSettings().ariaLabel);
  sliderWrapper.classList.add(this.getSettings().className);

  // Move the current HTML for the slide show in the new wrapper
  var sliderSelector = document.querySelector(this._selector);
  sliderSelector.parentNode.insertBefore(sliderWrapper, sliderSelector);
  sliderWrapper.appendChild(sliderSelector);

  // Easy </UL> </LI> selector
  this._slides = sliderWrapper.querySelectorAll(this._selector + ' > div');

  // Set attribute and size
  this._element.style.position = 'relative';
  this._element.setAttribute('aria-live', this.getSettings().autoplay ? 'off' : 'polite');
  this.initSlidesSize();

  window.addEventListener('resize', function () {
    _this4.setSize();
  });

  // Set all the slides
  this._slides.forEach(function (item, index) {
    item.setAttribute('role', 'tabpanel');
    item.setAttribute('aria-labelledby', _this4._selector.slice(1) + '-tab-' + index);
    item.setAttribute('id', _this4._selector.slice(1) + '-tabpanel-' + index);
    item.setAttribute('aria-label', index + 1 + ' ' + _this4.getSettings().ofText + ' ' + _this4._slides.length);
    item.style.transition = 'all ' + _this4.getSettings().transitionSpeed + 'ms';
    item.style.opacity = 1;
    item.style.position = 'absolute';
    item.style.top = 0;
    item.style.left = 0;
    item.style.right = 0;
    item.style.display = 'none';

    if (index === _this4._sliderIndex) {
      item.style.display = 'block';
    }
  });

  /* DOTS */
  if (this.getSettings().dots) {
    // Create a wrapper for the dots
    this.dotsWrapper = document.createElement('div');
    this.dotsWrapper.classList.add('dots');
    this.dotsWrapper.setAttribute('role', 'tablist');
    this.dotsWrapper.setAttribute('aria-label', this.getSettings().tablistText);
    sliderWrapper.insertAdjacentElement('afterbegin', this.dotsWrapper);

    this._slides.forEach(function (item, index) {
      // Create a button dot
      var dotButton = document.createElement('button');
      dotButton.setAttribute('aria-controls', _this4._selector.slice(1) + '-tabpanel-' + index);
      dotButton.setAttribute('id', _this4._selector.slice(1) + '-tab-' + index);
      dotButton.setAttribute('slider-id', index);
      dotButton.setAttribute('role', 'tab');
      dotButton.setAttribute('tabindex', -1);

      if (index == _this4._sliderIndex) {
        dotButton.classList.add('active');
      }
      // the first one need to be accessible via [TAB]
      if (index == 0) {
        dotButton.setAttribute('tabindex', 0);
      }
      dotButton.textContent = _this4.getSettings().slideText + ' ' + (index + 1);
      _this4.dotsWrapper.insertAdjacentElement('beforeend', dotButton);

      // Event Listeners dots click
      dotButton.addEventListener('click', function (e) {
        _this4.setSlider(e.target.getAttribute('slider-id'));
      });

      // Event Listeners dots keyboard arrows
      dotButton.addEventListener('keydown', function (e) {
        // ->
        if (e.which == 39) {
          if (e.currentTarget.nextSibling !== null) {
            e.currentTarget.nextSibling.focus();
            _this4.setSlider(e.currentTarget.nextSibling.getAttribute('slider-id'));
          }
        }
        // <-
        if (e.which == 37) {
          if (e.currentTarget.previousSibling !== null) {
            e.currentTarget.previousSibling.focus();
            _this4.setSlider(e.currentTarget.previousSibling.getAttribute('slider-id'));
          }
        }
        // HOME
        if (e.which == 36) {
          e.currentTarget.parentNode.childNodes[0].focus();
          _this4.setSlider(e.currentTarget.parentNode.childNodes[0].getAttribute('slider-id'));
        }
        // END
        if (e.which == 35) {
          e.currentTarget.parentNode.childNodes[e.currentTarget.parentNode.childNodes.length - 1].focus();
          _this4.setSlider(e.currentTarget.parentNode.childNodes[e.currentTarget.parentNode.childNodes.length - 1].getAttribute('slider-id'));
        }
      });
    });
  }

  /* ARROWS */
  var prevBtn = document.createElement('button');
  var nextBtn = document.createElement('button');

  if (this.getSettings().arrows) {
    // Prev settings
    prevBtn.setAttribute('aria-controls', this._selector);
    prevBtn.textContent = this.getSettings().previousText;
    prevBtn.setAttribute('id', this._prevId);
    prevBtn.classList.add('prev');

    // Next settings
    nextBtn.setAttribute('aria-controls', this._selector);
    nextBtn.textContent = this.getSettings().nextText;
    nextBtn.setAttribute('id', this._nextId);
    nextBtn.classList.add('next');

    // Insert prev and next buttons in the dom
    sliderWrapper.insertAdjacentElement('afterbegin', nextBtn);
    sliderWrapper.insertAdjacentElement('afterbegin', prevBtn);
  }

  // AutoPlay logic
  var playBtn = document.createElement('button');

  if (this.getSettings().autoplay) {
    playBtn.setAttribute('id', this._playId);

    this._autoPlayInterval = setInterval(this.autoPlay, parseInt(this.getSettings().autoplaySpeed));

    if (this.getSettings().autoplay) {
      playBtn.textContent = this.getSettings().pauseText;
      playBtn.classList.add('playing');
      sliderWrapper.insertAdjacentElement('afterbegin', playBtn);
    } else {
      playBtn.textContent = this.getSettings().playText;
      playBtn.classList.add('paused');
    }
  }

  // Event Listeners controls
  document.addEventListener('click', debounce(function (e) {
    // play
    if (e.target && e.target.id == _this4._playId) {
      // Toggle classes for styling
      playBtn.classList.toggle('playing');
      playBtn.classList.toggle('paused');
      _this4._element.setAttribute('aria-live', _this4._element.getAttribute('aria-live') == 'polite' ? 'off' : 'polite');

      if (_this4._wasPlaying) {
        playBtn.textContent = _this4.getSettings().playText;
        _this4._canAutoSlide = false;
      } else {
        _this4._canAutoSlide = true;
        playBtn.textContent = _this4.getSettings().pauseText;
      }
      _this4._wasPlaying = !_this4._wasPlaying;
    }
    // prev
    else if (e.target && e.target.id == _this4._prevId) {
        _this4.setSlider(parseInt(_this4._sliderIndex) - 1);
      }
      // next
      else if (e.target && e.target.id == _this4._nextId) {
          _this4.setSlider(parseInt(_this4._sliderIndex) + 1);
        } else {}
  }, 200));

  // Gesture / Touch listener
  if (this.getSettings().gesture) {
    var gesture = new TinyGesture(this._element);
    // next
    gesture.on('swiperight', debounce(function () {
      _this4.setSlider(parseInt(_this4._sliderIndex) - 1);
    }, 200));
    // prev
    gesture.on('swipeleft', debounce(function () {
      _this4.setSlider(parseInt(_this4._sliderIndex) + 1);
    }, 200));
  }

  // Pause Hover && Focus
  if (this.getSettings().pauseOnHover) {
    sliderWrapper.addEventListener('mouseenter', function () {
      _this4._canAutoSlide = false;
      _this4._element.setAttribute('aria-live', 'polite');
    });
    sliderWrapper.addEventListener('mouseleave', function () {
      if (_this4._wasPlaying) {
        _this4._canAutoSlide = true;
        _this4._element.setAttribute('aria-live', 'off');
      }
    });

    // when focus on a button (except play/pause) the carousel stop and is "polite"
    var buttons = sliderWrapper.querySelectorAll('button');
    buttons.forEach(function (button, index) {
      if (button.getAttribute('id') !== _this4._playId) {
        button.addEventListener('focus', function () {
          _this4._canAutoSlide = false;
          _this4._element.setAttribute('aria-live', 'polite');
        });
      }
    });

    sliderWrapper.addEventListener('focusout', function (e) {
      if (!sliderWrapper.contains(e.relatedTarget)) {
        if (_this4._wasPlaying) {
          _this4._canAutoSlide = true;
          _this4._element.setAttribute('aria-live', 'off');
        }
      }
    });
  }
}

/*
 * Select a slide
 */


/**
 *  Functionn called before setSize
 *  setSize need the images to be fully loaded
 */


/**
 * Set the size of the container of the slides
 */


/**
 * function called by the setInterval autoplay
 */


/*
 * Return an Object of the settings
 */
;